<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Multi-Threaded Integer Performance: SPEC CPU2006 | BlogInfo</title><meta name=generator content="Hugo 0.98.0"><meta name=description content="Multi-Threaded Integer Performance on one core: SPEC CPU2006 Broadly speaking, the value of SPEC CPU2006's int rate test is questionable, as it puts too much emphasis on bandwidth and way too little emphasis on data synchronization. However, it does give some indication of the total &#34;raw&#34; integer compute power available.
We will make an attempt to understand the differences between IBM and Intel, but to be really accurate we would need to profile the software and runs dozens of tests while looking at the performance counters."><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/normalize.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel=stylesheet type=text/css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/cayman.css><link rel=apple-touch-icon sizes=180x180 href=./apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=./favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=./favicon-16x16.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css integrity=sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js integrity=sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><section class=page-header><h1 class=project-name>BlogInfo</h1><h2 class=project-tagline></h2><nav><a href=./index.html class=btn>Blog</a>
<a href=./sitemap.xml class=btn>Sitemap</a>
<a href=./index.xml class=btn>RSS</a></nav></section><section class=main-content><h1>Multi-Threaded Integer Performance: SPEC CPU2006</h1><div><strong>Publish date: </strong>2024-09-23</div><img src=https://cdn.statically.io/img/images.anandtech.com/doci/10435/POWER8heatsink_678x452.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><h2>Multi-Threaded Integer Performance on one core: SPEC CPU2006</h2><p>Broadly speaking, the value of SPEC CPU2006's int rate test is questionable, as it puts too much emphasis on bandwidth and way too little emphasis on data synchronization. However, it does give some indication of the total "raw" integer compute power available.</p><p>We will make an attempt to understand the differences between IBM and Intel, but to be really accurate we would need to profile the software and runs dozens of tests while looking at the performance counters. That would have set back this article a bit too much. So we can only make an educated guess based upon what the existing academic literature says and our experiences with both architectures.</p><p>The Intel CPU performance is the 100% baseline in each column.</p><table align=center border=1 bordercolor=#dddddd cellpadding=3 cellspacing=0 width=650><tbody readability=4><tr class=tlblue readability=8><td>Subtest<br>SPEC CPU2006<br>Integer</td><td>Application<br>Type</td><td>IBM<br>POWER8<br>vs<br>Xeon E5-2699v4<br>Single<br>Thread</td><td>IBM<br>​POWER8<br>vs<br>Xeon E5-2699v4<br>Max<br>Thread</td><td>IBM<br>​POWER8<br>vs<br>Xeon E5-2699v4<br>Top<br>performance</td></tr><tr><td class=tlgrey>400.perlbench</td><td class=tlgrey>Spam filter</td><td>N/A</td><td>N/A</td><td>N/A</td></tr><tr><td class=tlgrey>401.bzip2</td><td class=tlgrey>Compress</td><td>91%</td><td>139%</td><td>139%</td></tr><tr><td class=tlgrey>403.gcc</td><td class=tlgrey>Compiling</td><td>111%</td><td>185%</td><td>185%</td></tr><tr><td class=tlgrey>429.mcf</td><td class=tlgrey>Vehicle scheduling</td><td>121%</td><td>167%</td><td>167%</td></tr><tr><td class=tlgrey>445.gobmk</td><td class=tlgrey>Game AI</td><td>90%</td><td>156%</td><td>156%</td></tr><tr><td class=tlgrey>456.hmmer</td><td class=tlgrey>Protein seq. analyses</td><td>79%</td><td>79%</td><td>101%</td></tr><tr><td class=tlgrey>458.sjeng</td><td class=tlgrey>Chess</td><td>69%</td><td>117%</td><td>117%</td></tr><tr><td class=tlgrey>462.libquantum</td><td class=tlgrey>Quantum<br>sim</td><td>76%</td><td>160%</td><td>162%</td></tr><tr><td class=tlgrey>464.h264ref</td><td class=tlgrey>Video encoding</td><td>80%</td><td>120%</td><td>131%</td></tr><tr><td class=tlgrey>471.omnetpp</td><td class=tlgrey>Network<br>sim</td><td>100%</td><td>141%</td><td>141%</td></tr><tr><td class=tlgrey>473.astar</td><td class=tlgrey>Pathfinding</td><td>87%</td><td>156%</td><td>156%</td></tr><tr><td class=tlgrey>483.xalancbmk</td><td class=tlgrey>XML processing</td><td>70%</td><td>116%</td><td>116%</td></tr></tbody></table><p>On (geometric) average, a single thread running on the IBM POWER8 core runs about 13% slower than on an Intel Broadwell architecture core. So our suspicion that Intel is still a bit better at extracting parallelism when running a single thread is confirmed.</p><p>Intel gains the upper-hand in the applications where branch prediction plays an important role: chess (sjeng), pathfinding (astar), protein seq. analysis (hmmer), and AI (gobmk). Intel's branch misprediction penalty is lower if the other branch is available in the µop cache (the Decode Stream Buffer) and Intel has a few clever tricks that the IBM core does not have like the loop stream detector.</p><p>Where the POWER8 core shines is in the benchmarks where memory latency is important and where the load units are a bottleneck, like vehicle scheduling (mcf). This is also true, but in lesser degree, for the network simulation (omnetpp). The reason might be that omnetpp puts a lot of pressure on the OoO buffers, and Intel's architecture offers more room with its unified buffers, whereas IBM POWER8's buffers are more partitioned (see for example the issue queue). Meanwhile XML processing does a lot of pointer chasing, but quick profiling has shown that this benchmark mostly hits the L2, and somewhat the L3. So there's no disadvantage for Intel there. On the flip side, Xalancbmk is the benchmark with the highest pressure on the ROB. Again, the larger OOO buffers for one thread might help Intel to do better.</p><p>POWER8 also does well in GCC, which has a high percentage of branches in the instruction mix, but very few branch mispredictions. GCC compiling is latency sensitive, so a 3 cycle L1, a 13 cycle L2, and the fast 8MB L3 help.</p><p>Finally, the pathfinding (astar) benchmark does some intensive pointer chasing, but it misses the L1- and L2-cache much less often than xalancbmk, and has the highest amount of branch misprediction. So the impact of the pointer chasing and memory latency is thus minimal.</p><p>Once all threads are active, the IBM POWER8 core is able to outperform the Intel CPU by 41% (geomean average).</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH5xgJJuZpqro5rAtLXNoGSimp2oerG71p6pcWWglr%2B1eZBoaGk%3D</p><footer class=site-footer><span class=site-footer-credits>Made with <a href=https://gohugo.io/>Hugo</a>. © 2022. All rights reserved.</span></footer></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>