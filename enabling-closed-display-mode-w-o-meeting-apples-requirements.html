<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Enabling Closed-Display Mode w/o Meeting Apple's Requirements | BlogInfo</title><meta name=generator content="Hugo 0.98.0"><meta name=description content="EDIT: I have heavily edited this question after making some significant new discoveries and the question not having any answers yet. Historically/AFAIK, keeping your Mac awake while in closed-display mode and not meeting Apple's requirements, has only been possible with a kernel extension (kext), or a command run as root. Recently however, I have discovered that there must be another way. I could really use some help figuring out how to get this working for use in a (100% free, no IAP) sandboxed Mac App Store (MAS) compatible app."><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/normalize.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel=stylesheet type=text/css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/cayman.css><link rel=apple-touch-icon sizes=180x180 href=./apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=./favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=./favicon-16x16.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css integrity=sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js integrity=sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><section class=page-header><h1 class=project-name>BlogInfo</h1><h2 class=project-tagline></h2><nav><a href=./index.html class=btn>Blog</a>
<a href=./sitemap.xml class=btn>Sitemap</a>
<a href=./index.xml class=btn>RSS</a></nav></section><section class=main-content><h1>Enabling Closed-Display Mode w/o Meeting Apple's Requirements</h1><div><strong>Publish date: </strong>2024-02-26</div><p><strong>EDIT:</strong> I have heavily edited this question after making some significant new discoveries and the question not having any answers yet.</p><p>Historically/AFAIK, keeping your Mac awake while in closed-display mode and not meeting <a href=# rel="nofollow noreferrer">Apple's requirements</a>, has only been possible with a <a href=# rel="nofollow noreferrer">kernel extension</a> (kext), or a <a href=# rel="nofollow noreferrer">command</a> run as root. Recently however, I have discovered that there must be another way. I could really use some help figuring out how to get this working for use in a (100% free, no IAP) sandboxed Mac App Store (MAS) compatible app.</p><p>I have confirmed that some other MAS apps are able to do this, and it looks like they might be writing <code>YES</code> to a key named <code>clamshellSleepDisabled</code>. Or perhaps there's some other trickery involved that causes the key value to be set to YES? I found the function in <a href=# rel="nofollow noreferrer">IOPMrootDomain.cpp</a>:</p><pre><code>void IOPMrootDomain::setDisableClamShellSleep( bool val ) { if (gIOPMWorkLoop-&gt;inGate() == false) { gIOPMWorkLoop-&gt;runAction( OSMemberFunctionCast(IOWorkLoop::Action, this, &amp;IOPMrootDomain::setDisableClamShellSleep), (OSObject *)this, (void *)val); return; } else { DLOG("setDisableClamShellSleep(%x)\n", (uint32_t) val); if ( clamshellSleepDisabled != val ) { clamshellSleepDisabled = val; // If clamshellSleepDisabled is reset to 0, reevaluate if // system need to go to sleep due to clamshell state if ( !clamshellSleepDisabled &amp;&amp; clamshellClosed) handlePowerNotification(kLocalEvalClamshellCommand); } } } </code></pre><p>I'd like to give this a try and see if that's all it takes, but I don't really have any idea about how to go about calling this function. It's certainly not a part of the <a href=# rel="nofollow noreferrer">IOPMrootDomain</a> documentation, and I can't seem to find any helpful example code for functions that are in the IOPMrootDomain documentation, such as <code>setAggressiveness</code> or <code>setPMAssertionLevel</code>. Here's some evidence of what's going on behind the scenes according to Console:</p><p><a href=# rel="nofollow noreferrer"><img src=https://cdn.statically.io/img/i.stack.imgur.com/axe9T.png alt="Image of message logs from Console.app" style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>I've had a tiny bit of experience working with IOMProotDomain via adapting some of <a href=# rel="nofollow noreferrer">ControlPlane</a>'s source for another project, but I'm at a loss for how to get started on this. Any help would be greatly appreciated. Thank you!</p><p><strong>EDIT: With @pmdj's contribution/answer, this has been solved!</strong></p><p>Full example project: <a href=# rel="nofollow noreferrer">https://github.com/x74353/CDMManager</a></p><p>This ended up being surprisingly simple/straightforward:</p><p><strong>1. Import header:</strong></p><pre><code>#import &lt;IOKit/pwr_mgt/IOPMLib.h&gt; </code></pre><p><strong>2. Add this function in your implementation file:</strong></p><pre><code>IOReturn RootDomain_SetDisableClamShellSleep (io_connect_t root_domain_connection, bool disable) { uint32_t num_outputs = 0; uint32_t input_count = 1; uint64_t input[input_count]; input[0] = (uint64_t) { disable ? 1 : 0 }; return IOConnectCallScalarMethod(root_domain_connection, kPMSetClamshellSleepState, input, input_count, NULL, &amp;num_outputs); } </code></pre><p><strong>3. Use the following to call the above function from somewhere else in your implementation:</strong></p><pre><code>io_connect_t connection = IO_OBJECT_NULL; io_service_t pmRootDomain = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOPMrootDomain")); IOServiceOpen (pmRootDomain, current_task(), 0, &amp;connection); // 'enable' is a bool you should assign a YES or NO value to prior to making this call RootDomain_SetDisableClamShellSleep(connection, enable); IOServiceClose(connection); </code></pre><span class=d-none itemprop=commentCount>2</span><h2 class=mb0 data-answercount=1>1 Answer</h2><p>I have no personal experience with the PM root domain, but I do have extensive experience with IOKit, so here goes:</p><ul><li>You want <code>IOPMrootDomain::setDisableClamShellSleep()</code> to be called.</li><li>A code search for sites calling <code>setDisableClamShellSleep()</code> quickly reveals a location in <code>RootDomainUserClient::externalMethod()</code>, in the file <code>iokit/Kernel/RootDomainUserClient.cpp</code>. This is certainly promising, as <code>externalMethod()</code> is what gets called in response to user space programs calling the <code>IOConnectCall*()</code> family of functions.</li></ul><p>Let's dig in:</p><pre><code>IOReturn RootDomainUserClient::externalMethod( uint32_t selector, IOExternalMethodArguments * arguments, IOExternalMethodDispatch * dispatch __unused, OSObject * target __unused, void * reference __unused ) { IOReturn ret = kIOReturnBadArgument; switch (selector) { … … … case kPMSetClamshellSleepState: fOwner-&gt;setDisableClamShellSleep(arguments-&gt;scalarInput[0] ? true : false); ret = kIOReturnSuccess; break; … </code></pre><p>So, to invoke <code>setDisableClamShellSleep()</code> you'll need to:</p><li>Open a user client connection to <code>IOPMrootDomain</code>. This looks straightforward, because:<ul><li>Upon inspection, <code>IOPMrootDomain</code> has an <code>IOUserClientClass</code> property of <code>RootDomainUserClient</code>, so <code>IOServiceOpen()</code> from user space will by default create an <code>RootDomainUserClient</code> instance.</li><li><code>IOPMrootDomain</code> does not override the <code>newUserClient</code> member function, so there are no access controls there.</li><li><code>RootDomainUserClient::initWithTask()</code> does not appear to place any restrictions (e.g. root user, code signing) on the connecting user space process.</li><li>So it should simply be a case of running this code in your program:</li></ul></li><pre><code> io_connect_t connection = IO_OBJECT_NULL; IOReturn ret = IOServiceOpen( root_domain_service, current_task(), 0, // user client type, ignored &amp;connection); </code></pre><li>Call the appropriate external method.<ul><li>From the code excerpt earlier on, we know that the selector must be <code>kPMSetClamshellSleepState</code>.</li><li><code>arguments->scalarInput[0]</code> being zero will call <code>setDisableClamShellSleep(false)</code>, while a nonzero value will call <code>setDisableClamShellSleep(true)</code>.</li><li>This amounts to:</li></ul></li><pre><code>IOReturn RootDomain_SetDisableClamShellSleep(io_connect_t root_domain_connection, bool disable) { uint32_t num_outputs = 0; uint64_t inputs[] = { disable ? 1 : 0 }; return IOConnectCallScalarMethod( root_domain_connection, kPMSetClamshellSleepState, &amp;inputs, 1, // 1 = length of array 'inputs' NULL, &amp;num_outputs); } </code></pre><li>When you're done with your <code>io_connect_t</code> handle, don't forget to <code>IOServiceClose()</code> it.</li><p>This should let you toggle clamshell sleep on or off. Note that there does not appear to be any provision for automatically resetting the value to its original state, so if your program crashes or exits without cleaning up after itself, whatever state was last set will remain. This might not be great from a user experience perspective, so perhaps try to defend against it somehow, for example in a crash handler.</p><span class=d-none itemprop=commentCount>2</span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJobHJtaWl%2Bc3%2BOnqWampyeu6h5wqWmrJ2UYrGqv8%2BlmLJlnaSxpnnWZqZmpZWawaq6xmaYqaicmsBuvsSqrKKqlaKyr8DS</p><footer class=site-footer><span class=site-footer-credits>Made with <a href=https://gohugo.io/>Hugo</a>. © 2022. All rights reserved.</span></footer></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>